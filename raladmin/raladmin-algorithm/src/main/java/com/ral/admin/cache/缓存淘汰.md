#### 缓存淘汰策略
##### FIFO算法
FIFO算法即先进先出算法，常采用队列实现。在缓存中，它的设计原则是：如果一个数据最先进入缓存中，则应该最早淘汰掉。
新访问的数据插入FIFO队列的尾部，队列中数据由队到队头按顺序顺序移动，队列满时，删除队头的数据。

##### LRU算法
LRU算法是根据对数据的历史访问次数来进行淘汰数据的，通常使用链表来实现。在缓存中，它的设计原则是：如果数据最近被访问过，那么将来它被访问的几率也很高。
- 新加入的数据插入到链表的头部
- 每当缓存命中时(即缓存数据被访问)，则将数据移到链表头部
- 当来链表已满的时候，将链表尾部的数据丢弃

LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。
- 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。
- 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。

LinkedHashMap：
- void afterNodeAccess(Node<K,V> p) { }
  其作用就是在访问元素之后，将该元素放到双向链表的尾巴处(所以这个函数只有在按照读取的顺序的时候才会执行)，如何优美的实现在双向链表中将指定元素放入链尾！
- void afterNodeRemoval(Node<K,V> p) { }
  其作用就是在删除元素之后，将元素从双向链表中删除，很优美的方式在双向链表中删除节点！
- void afterNodeInsertion(boolean evict) { }
  在插入新元素之后，需要回调函数判断是否需要移除一直不用的某些元素！
  
##### LFU算法
LFU算法是根据数据的历史访问频率来淘汰数据，因此，LFU算法中的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。在缓存中，它的设计原则是：如果数据被访问多次，那么将来它的访问频率也会更高。
- 新加入数据插入到队列尾部(引用计数为1;
- 队列中的数据被访问后，引用计数增加，队列重新排序;
- 当需要淘汰数据时，将已经排序的列表最后的数据块删除。