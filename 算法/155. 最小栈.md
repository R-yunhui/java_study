## 解法一
### 思路
使用另外一个栈来存储最小值，用6，7，5举例
1. 放入6，原始栈为6；最小栈为6
2. 放入7，原始栈为6，7；最小栈为6，6
3. 放入7，原始栈为6，7，5；最小栈为6，6，5

### 时空复杂度
- 时间复杂度：所有操作都是O（1）
- 空间复杂度：额外使用了一个栈O（n）
## 解法二
### 思路
重点是最小值，我们可以用栈存储当前值与最小值的差值， min依然是当前所有数中最小的，当取出时根据差值对最小值还愿，可以分为放入与取出讨论
- 放入时，放入值设为x
  - 空栈：设置放入值为最小值，放入当前值x-min，此时相同为0
  - 放入值大于等于最小值：放入x-min，最小值不变
  - 放入值小于最小值：放入x-min，最小值变为放入值
- 取出时，取出值设为y
  - 空栈：返回0
  - 取出值为大于等于0：取出值比之前最小值大，返回y+min
  - 取出值小于0：取出值比之前最小值小，返回min，设置最小值为min-y（通过列出公式推导出来，x-beforeMin=y，为负数时min值有变动，x=nowMin，所以直接返回min，之前的最小值为beforeMin=x（现在的min）-y）

我们举例如下，
放入6,7,5
1. 放入6，栈为 0；min为6
2. 放入7，栈为0，1；min为6
3. 放入5，栈为0,1，-1；min为5

取出时
1. 取出5，返回5（min），设置min为6
2. 取出7，返回7（min+1）
3. 取出6，返回6（min+0）
### 时空复杂度
- 时间复杂度：所有操作都是O（1）
- 空间复杂度：没有使用额外的空间O（1）

## 解法三
### 思路
自己使用双向链表来实现栈，node里面额外维护一个min，当依次添加6，7，5时，形成链表如下
prev（）<-->node1(val=6,min=6)<-->node2(val=7,min=6)<-->node3(val=5,min=5)

### 时空复杂度
- 时间复杂度：所有操作都是O（1）
- 空间复杂度：没有使用额外的空间O（1）






