## 解法一
### 思路
所有的丑数都是由更小的丑数乘以2、3、5中一个产生的，1是最小的丑数，用一个 hashset 存储产生的丑数，因为需要的是前1690个丑数，记录的丑数需要是有序的，所以我们用最小堆记录产生的丑数，每次从最小堆中拿一个最小的去产生新的丑数，最终产生1690个丑数完成。

我们需要三个结构，一个数组 nums 记录产生的丑数，一个 set记录已经出现过的丑数，一个最小堆p记录出现过的丑数的顺序

- 初始化：set：1；p：1；nums：没有元素
- 第一轮：从最小堆拿到1，与2、3、5相乘加入set与p，set：1，2,3,5；p：2,3,5；nums：1
- 第二轮：从最小堆拿到2，与2、3、5相乘加入set与p，set：1,2,3,4,5，6,10；p：3,4,5,6,10；nums：1,2
- .......
- 第1690轮：构建好长度为1690的丑数升序数组，结束循环

### 时空复杂度
- 时间复杂度：与n的比例无关O（1）
- 空间复杂度：三个结构都与n的比例无关O（1）
## 解法二
### 思路
动态规划，因为下一个丑数肯定从前序丑数乘以2,3,5得出，并且前序丑数都是升序，我们可以分别用三个指针表明乘以2的丑数走到哪里了，乘以3的丑数走到哪里了，乘以5的丑数走到哪里了，这三个产生的最小数就是下一个丑数
- 第一轮：1 (p2、p3、p5都在位置0)最小为2，下一个丑数为2，p2+=1
- 第二轮：1 2 (p2在位置1，p3、p5,在位置0)最小为3，下一个丑数为3，p3+=1
- .......
- 第1690轮，产生长度1690有序丑数数组      
### 时空复杂度
- 时间复杂度：与n的比例无关O（1）
- 空间复杂度：三个指向，一个1690长度数组，常数空间O（1）




